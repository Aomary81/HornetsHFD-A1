package org.csc133.a1;

import static com.codename1.ui.CN.*;

import com.codename1.charts.util.ColorUtil;
import com.codename1.components.SpanLabel;
import com.codename1.system.Lifecycle;
import com.codename1.ui.*;
import com.codename1.ui.Button;
import com.codename1.ui.Component;
import com.codename1.ui.Dialog;
import com.codename1.ui.Font;
import com.codename1.ui.Graphics;
import com.codename1.ui.TextArea;
import com.codename1.ui.events.ActionEvent;
import com.codename1.ui.events.ActionListener;
import com.codename1.ui.geom.Point;
import com.codename1.ui.layouts.*;
import com.codename1.io.*;
import com.codename1.ui.layouts.BorderLayout;
import com.codename1.ui.plaf.*;
import com.codename1.ui.util.Resources;
import com.codename1.ui.util.UITimer;
import jdk.internal.jimage.ImageStrings;

import java.awt.*;
import java.util.ArrayList;
import java.util.Random;

/**
 * This file was generated by <a href="https://www.codenameone.com/">Codename One</a> for the purpose
 * of building native mobile applications using Java.
 */
public class AppMain extends Lifecycle {

    @Override
    public void runApp() {
        Game game = new Game();
        game.show();
    }

}

class Game extends Form implements Runnable{
    private GameWorld gw;

    public Game(){
        gw = new GameWorld();
        UITimer timer = new UITimer(this);
        timer.schedule(100, true, this);

        // Exit Key
        addKeyListener('Q', new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent evt) {
                gw.quit();
            }
        });

        //Left Arrow used to turn the helicopter left
        addKeyListener(-93, new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent evt) {
                gw.turnLeft();
            }
        });

        // Right Arrow used to turn the helicopter right
        addKeyListener(-94, new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent evt) {

                gw.turnRight();
            }
        });

        // Up Arrow to speed up the helicopter
        addKeyListener(-91, new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent evt) {

                gw.speedUp();
            }
        });

        // Down Arrow to slow down and stop the helicopter
        addKeyListener(-92, new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent evt) {
                gw.slowDown();
            }
        });

        // dump water
        addKeyListener('f', new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent evt) {
            gw.fight();
            }

        });

        // drink water
        addKeyListener('d', new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent evt) {
                gw.drink();
            }
        });


    }

    @Override
    public void run() {
        gw.tick();
        repaint();
    }

    public void paint(Graphics g){
        super.paint(g);
        gw.draw(g);
    }
}

class GameWorld{
    final Button restart= new Button("Restart");
    final Button exit = new Button("Exit");
    Helipad helipad;
    River river;
    Helicopter helicopter;
    int water, fuel;
    ArrayList<Fire> fires;

    public GameWorld(){
        init();
    }

    void init(){
        helipad = new Helipad();
        river = new River();
        helicopter = new Helicopter();
        fires = new ArrayList<>();
        for(int i = 0; i < 3; i++) {
            fires.add(new Fire());
        }
    }

    void draw(Graphics g){
        g.clearRect(0, 0, Display.getInstance().getDisplayWidth(),
                Display.getInstance().getDisplayHeight());
        helipad.draw(g);
        river.draw(g);
        for(int i = 0; i < 3; i++) {
            fires.get(i).draw(g);
        }
        helicopter.draw(g);
    }

    void tick(){
        for(int i = 0; i < 3; i++) {
            fires.get(i).grow();
        }
        helicopter.move();
        fuel = helicopter.fuelConsumption();
        water = helicopter.getWaterLevel();
        if(fuel <= 0){
            gameOver();
        }
        if(fires.isEmpty() && helicopter.isOverHelipad(helipad)){
            youWin();
        }
    }

    // method to call helicopter command turn left
    void turnLeft() {
        helicopter.turningL();
    }
    // method to call helicopter command turn right
    void turnRight() {
        helicopter.turningR();
    }
    // method to call helicopter command to go forward and increase speed
    void speedUp() {
        helicopter.accelerate();
    }
    // method to call helicopter command to slow down and stop
    void slowDown()    {
        helicopter.decelerate();
    }

    // Method for filling the water tank on helicopter
    void drink(){
        if(helicopter.overRiver(river)) {
            helicopter.drinkWater();
        }
    }

    // Method for dropping water on fire
    void fight() {
        ArrayList<Fire> deadFlames = new ArrayList<>();
        for (int i = 0; i < 3; i++) {
            if (helicopter.overFire1(fires.get(i))) {
                if (fires.get(i).getFireSize1() < helicopter.getWaterLevel()) {
                    deadFlames.add(fires.get(i));
                }
            }

        }
        helicopter.fightFire();
    }

    // Losing condition Dialog Window
    void gameOver(){
        restart.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent actionEvent) {

            }
        });
        exit.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent actionEvent) {
                quit();

            }
        });
        Dialog dlg = new Dialog("GAME OVER! YOU LOSE!!!");
        dlg.setLayout(new BorderLayout());
        dlg.add(BorderLayout.WEST, restart);
        dlg.add(BorderLayout.CENTER, exit);
        dlg.show();
    }

    // Win condition dialog window
    private void youWin() {
        restart.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent actionEvent) {

            }
        });
        exit.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent actionEvent) {
                quit();

            }
        });
        Dialog dlg = new Dialog("GAME OVER! YOU WIN!!! Your Score was: " + fuel);
        dlg.setLayout(new BorderLayout());
        dlg.add(BorderLayout.WEST, restart);
        dlg.add(BorderLayout.CENTER, exit);
        dlg.show();
    }

    // Method for exiting the game
    void quit() {
        Display.getInstance().exitApplication();
    }
}

class River {
    Point location;
    int top, bottom, start, end;

    public River(){
        location = new Point(Display.getInstance().getDisplayWidth()/2,
                Display.getInstance().getDisplayHeight() * 5/12);
        start = location.getX() - location.getX();
        end = location.getX() + location.getX();
        top = location.getY() * 4/5;
        bottom = location.getY() * 2/5;
    }

    // Returns the Top and Bottom shoreline of River
    int getRiverNorth(){
        return top;
    }

    int getRiverSouth(){
        return top + bottom;
    }

    void draw(Graphics g) {
        g.setColor(ColorUtil.BLUE);
        g.drawRect(start, top, end, bottom);
    }

}

class Helipad {
    Point locationCenter;
    int squareSize, circleSize;

    public Helipad(){
        squareSize = 200;
        circleSize = 150;
        locationCenter = new Point(Display.getInstance().getDisplayWidth()/2,
                Display.getInstance().getDisplayHeight() - squareSize - 10 );
    }
    // Get Helipads X and Y coordinates
    public int getHelipadX() {
        return locationCenter.getX();
    }

    public int getHelipadY() {
        return locationCenter.getY();
    }

    void draw(Graphics g){
        g.setColor(ColorUtil.GRAY);
        g.drawArc(locationCenter.getX() - circleSize/2,
                locationCenter.getY() - circleSize/2,
                circleSize, circleSize, 0, 360);
        g.drawRect(locationCenter.getX() - squareSize/2,
                locationCenter.getY() - squareSize/2,
                squareSize, squareSize,5);
    }

}

class Fire {
    private Point location1;
    private int fireSize1;
    private Random r;

    public Fire(){
        r = new Random();
        fireSize1 = r.nextInt(400);
        location1 = new Point(Display.getInstance().getDisplayWidth()/4 +
                r.nextInt(Display.getInstance().getDisplayWidth()/4),
                r.nextInt(Display.getInstance().getDisplayHeight())/3);
            }

    // Increase and decrease fire's size
    void grow(){
        fireSize1 = fireSize1 + r.nextInt(5);
    }

    int shrink1(int water) {
        return fireSize1 = fireSize1 - (water/4);
    }

    // Gets the Point coordinate for Fires X and Y and the fire's size
    int getFire1X() {
        return location1.getX() + fireSize1;
    }
    int getFire1Y(){
        return location1.getY() + fireSize1;
    }
    int getFireSize1(){
        return fireSize1;
    }

    void draw(Graphics g) {
        g.setColor(ColorUtil.rgb(255, 0, 0));
        g.fillArc(location1.getX() - fireSize1/4, location1.getY() - fireSize1/4,
                fireSize1 / 2, fireSize1 / 2,
                0, 360);
        g.setColor(ColorUtil.WHITE);
        g.setFont(Font.createSystemFont(FACE_MONOSPACE, STYLE_BOLD, SIZE_MEDIUM));
        g.drawString("" + fireSize1, location1.getX() + fireSize1 / 4,
                location1.getY() + fireSize1/4);
    }

}

class Helicopter {
    Point locationHeli, locationTail, center, turning;
    int heliSize, tailSize, currentIndex;
    int  fuel, rX, rY, speed, x2, y2, water;
    ArrayList<Point> turn;

    public Helicopter(){
        heliSize = 50;
        tailSize = 100;
        locationHeli = new Point(Display.getInstance().getDisplayWidth()/2,
                Display.getInstance().getDisplayHeight() - 210);
        locationTail = new Point(locationHeli.getX(), locationHeli.getY());
        center = new Point(Display.getInstance().getDisplayWidth()/2,
                Display.getInstance().getDisplayHeight() - 210);
        turn = new ArrayList<>();
        currentIndex = 0;
        fuel = 25000;
        for (int i = 1; i < 25; i++) {
            double angle = Math.toRadians(360 / 24 * i - 105);
            rX = (int) ((tailSize * Math.cos(angle)));
            rY = (int) ((tailSize * Math.sin(angle)));
            turning = new Point(rX, rY);
            turn.add(turning);
        }
    }

    // Changes the direction the helicopter is pointing
    void move(){
        if(speed > 0 && speed <= 10) {
            if ((center.getX() == x2) && (center.getY() > y2)) {
                center.setY(center.getY() - speed);
                y2 = y2 -  speed;
            } else if ((center.getX() == x2) && (center.getY() < y2)) {
                center.setY(center.getY() + speed);
                y2 = y2 + speed;
            } else if ((center.getY() == y2) && (center.getX() > x2)) {
                center.setX(center.getX() - speed);
                x2 = x2 - speed;
            } else if ((center.getY() == y2) && (center.getX() < x2)) {
                center.setX(center.getX() + speed);
                x2 = x2 + speed;
            } else if ((center.getX() > x2) && (center.getY() > y2)) {
                center.setY(center.getY() - speed);
                y2 = y2 - speed;
                center.setX(center.getX() - speed);
                x2 = x2 - speed;
            } else if ((center.getX() > x2) && (center.getY() < y2)) {
                center.setY(center.getY() + speed);
                y2 = y2 + speed;
                center.setX(center.getX() - speed);
                x2 = x2 - speed;
            } else if ((center.getX() < x2) && (center.getY() > y2)) {
                center.setY(center.getY() - speed);
                y2 = y2 - speed;
                center.setX(center.getX() + speed);
                x2 = x2 + speed;
            } else if ((center.getX() < x2) && (center.getY() < y2)) {
                center.setY(center.getY() + speed);
                y2 = y2 + speed;
                center.setX(center.getX() + speed);
                x2 = x2 + speed;
            }
        }
    }

    // Uses the turn ArrayList to change direction
    void turningR() {
        currentIndex++;
        if (currentIndex > turn.size() - 1) {
            currentIndex = 0;
        }
    }

    // Uses the turn ArrayList to change direction
    void turningL(){
        if(currentIndex == 0){
            currentIndex = turn.size() - 1;
        }
        currentIndex--;
    }

    // changes the speed of the helicopter
    void accelerate(){
        if(speed >= 0 && speed < 10) {
            speed++;
        }
        else{
            speed = 10;
        }
    }

    // changes the speed of the helicopter
    void decelerate() {
        if(speed > 0) {
            speed--;
        }
        else{
            speed = 0;
        }
    }

    // Changes the fuel level
    int fuelConsumption(){
            fuel = fuel - ((speed * speed) + 5);

            if(fuel <= 0) {
                fuel = 0;
            }
            return fuel;
        }

    // Command method to pick up Water
    void drinkWater(){
        if(speed <= 2){
            water = water + 100;
            }
        if(water >= 1000){
            water = 1000;
        }
    }

    // Checks to see if center of helicopter is over the river
    boolean overRiver(River r){
        if((r.getRiverNorth() + heliSize/2 < center.getY()) &&
                (r.getRiverSouth() - heliSize/2 > center.getY())){
            return true;
        }
        else{
            return false;
        }
    }

    // Check is helicopter is over the fire
    boolean overFire1(Fire f) {
        if ((((f.getFire1X() - center.getX()) <= heliSize) ||
                ((center.getX() - f.getFire1X()) <= heliSize)) &&
                (((f.getFire1Y() - center.getY()) <= heliSize) ||
                        (center.getY() - f.getFire1Y() <= heliSize))) {
            return true;
        } else {
            return false;
        }
    }

    // Check to see if Helicopter is over the Helipad
    boolean isOverHelipad(Helipad pad) {
        if ((((pad.getHelipadX() - center.getX()) <= heliSize) ||
                ((center.getX() - pad.getHelipadX()) <= heliSize)) &&
                (((pad.getHelipadY() - center.getY()) <= heliSize) ||
                        (center.getY() - pad.getHelipadY() <= heliSize)) && speed == 0) {
            return true;
        } else {
            return false;
        }
    }

    // Current Water Level
    int getWaterLevel(){
        return water;
    }

    // Drops all water of fire
    void fightFire(){
        water = 0;
    }

    void draw(Graphics g) {
        g.setColor(ColorUtil.rgb(255, 255, 0));
        g.fillArc(center.getX() - heliSize / 2, center.getY() - heliSize / 2,
                heliSize, heliSize, 0, 360);

        x2 = turn.get(currentIndex).getX() + center.getX();
        y2 = turn.get(currentIndex).getY() + center.getY();
        g.setColor(ColorUtil.rgb(255, 255, 0));
        g.drawLine(center.getX(), center.getY(), x2, y2);
        g.setColor(ColorUtil.WHITE);
        g.setFont(Font.createSystemFont(FACE_MONOSPACE, STYLE_BOLD, SIZE_MEDIUM));
        g.drawString("fuel: " + fuel, center.getX() + heliSize,
                center.getY() + heliSize);
        g.drawString("water: " + water, center.getX() + heliSize,
                center.getY() + 20 + heliSize);
    }


}
