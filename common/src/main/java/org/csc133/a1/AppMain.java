/*
Name: Aaron O'Mary
Class: CSC 133 - Section 03
Student Id last 4: 9233
Project: Assignment A1 - Hornets HFD
*/

package org.csc133.a1;

import static com.codename1.ui.CN.*;

import com.codename1.charts.util.ColorUtil;
import com.codename1.components.SpanLabel;
import com.codename1.system.Lifecycle;
import com.codename1.ui.*;
import com.codename1.ui.Button;
import com.codename1.ui.Component;
import com.codename1.ui.Dialog;
import com.codename1.ui.Font;
import com.codename1.ui.Graphics;
import com.codename1.ui.TextArea;
import com.codename1.ui.events.ActionEvent;
import com.codename1.ui.events.ActionListener;
import com.codename1.ui.geom.Point;
import com.codename1.ui.layouts.*;
import com.codename1.io.*;
import com.codename1.ui.layouts.BorderLayout;
import com.codename1.ui.plaf.*;
import com.codename1.ui.util.Resources;
import com.codename1.ui.util.UITimer;
import jdk.internal.jimage.ImageStrings;

import java.awt.*;
import java.awt.Label;
import java.util.ArrayList;
import java.util.Random;

/**
 * This file was generated by <a href="https://www.codenameone.com/"
 * >Codename One</a> for the purpose
 * of building native mobile applications using Java.
 */
public class AppMain extends Lifecycle {

    @Override
    public void runApp() {
        Game game = new Game();
        game.show();
    }
}

class Game extends Form implements Runnable{
    private GameWorld gw;

    public Game(){
        gw = new GameWorld();
        UITimer timer = new UITimer(this);
        timer.schedule(100, true, this);
        // Exit Key
        addKeyListener('Q', evt -> gw.quit());
        //Left Arrow used to turn the helicopter left
        addKeyListener(-93, evt -> gw.turnLeft());
        // Right Arrow used to turn the helicopter right
        addKeyListener(-94, evt -> gw.turnRight());
        // Up Arrow to speed up the helicopter
        addKeyListener(-91, evt -> gw.speedUp());
        // Down Arrow to slow down and stop the helicopter
        addKeyListener(-92, evt -> gw.slowDown());
        // dump water
        addKeyListener('f', evt -> gw.fight());
        // drink water
        addKeyListener('d', evt -> gw.drink());
    }
    @Override
    public void run() {
        gw.tick();
        repaint();
    }
    public void paint(Graphics g){
        super.paint(g);
        gw.draw(g);
    }
}

class GameWorld{
    private final Button RESTART = new Button("Restart");
    private final Button EXIT = new Button("Exit");
    final static int DISP_W = Display.getInstance().getDisplayWidth();
    final static int DISP_H = Display.getInstance().getDisplayHeight();
    private Helipad helipad;
    private River river;
    private Helicopter helicopter;
    private int water, fuel, ticks;
    private ArrayList<Fire> fires;
    private ArrayList <Fire> deadFires;
    private Random r;
    public GameWorld(){
        init();
    }

    void init(){
        helipad = new Helipad();
        river = new River();
        helicopter = new Helicopter();
        fires = new ArrayList<>();
        deadFires = new ArrayList<>();
        r = new Random();
        fuel = 25000;
        water = 0;
        for(int i = 0; i < 3; i++) {
            fires.add(new Fire());
        }
        fires.get(1).setLocationX(DISP_W/2 + r.nextInt(DISP_W/4));
        fires.get(1).setLocationY(r.nextInt(DISP_H/4));
        fires.get(2).setLocationX(DISP_W/4 + r.nextInt(DISP_W/4));
        fires.get(2).setLocationY(DISP_H/2 +  r.nextInt(DISP_H/4));
        ticks = 0;
    }

    void draw(Graphics g){
        g.clearRect(0, 0, DISP_W, DISP_H);
        helipad.draw(g);
        river.draw(g);
        for(Fire spot : fires) {
            spot.draw(g);
        }
        helicopter.draw(g);
    }

    void tick(){
        ticks++;
        if(ticks % 3 == 0) {
            if (!fires.isEmpty()) {
                for (Fire spot : fires) {
                    spot.grow();
                }
            }
        }
        helicopter.move();
        fuel = helicopter.fuelConsumption();
        water = helicopter.getWaterLevel();
        if((fuel <= 0) ||
                (fires.isEmpty() && helicopter.isOverHelipad(helipad))){
            gameOver();
        }
     }
    // method to call helicopter command turn left
    void turnLeft() {
        helicopter.turningL();
    }
    // method to call helicopter command turn right
    void turnRight() {
        helicopter.turningR();
    }
    // method to call helicopter command to go forward and increase speed
    void speedUp() {
        helicopter.accelerate();
    }
    // method to call helicopter command to slow down and stop
    void slowDown()    {
        helicopter.decelerate();
    }
    // Method for filling the water tank on helicopter
    void drink(){
        if(helicopter.overRiver(river)) {
            helicopter.drinkWater();
        }
    }
    // Method for dropping water on fire
    void fight() {
        for (Fire spot : fires) {
            if (helicopter.overFire(spot)) {
                if ((water/2) > spot.getFireSize()) {
                    deadFires.add(spot);
                } else {
                    spot.shrink(water);
                }
            }
        }
        fires.removeAll(deadFires);
        helicopter.fightFire();
    }
    // Losing condition Dialog Window
    void gameOver(){
        RESTART.addActionListener(actionEvent -> {
            Game game = new Game();
            game.show();
        });
        EXIT.addActionListener(actionEvent -> quit());
        Dialog dlg = new Dialog("GAME OVER!");
        dlg.setLayout(new BorderLayout());
        if(fuel <= 0) {
            dlg.add(BorderLayout.CENTER, "YOU LOSE!!! TRY AGAIN!!!");
        }
        else{
            dlg.add(BorderLayout.CENTER,"Your High Score is: " + fuel);
        }
        dlg.add(BorderLayout.EAST, RESTART);
        dlg.add(BorderLayout.WEST, EXIT);
        dlg.show(DISP_H / 24 * 10, DISP_H / 24 * 10, DISP_W / 24 * 9,
                DISP_H / 24 * 9);
    }

    // Method for exiting the game
    void quit() {
        Display.getInstance().exitApplication();
    }
}

class River {
    private final static int DISP_W = Display.getInstance().getDisplayWidth();
    private final static int DISP_H = Display.getInstance().getDisplayHeight();
    private Point location;
    private int top, bottom, start, end;

    public River(){
        location = new Point(DISP_W/2,
                DISP_H * 5/12);
        start = location.getX() - location.getX();
        end = location.getX() + location.getX();
        top = location.getY() * 4/5;
        bottom = location.getY() * 2/5;
    }
    // Returns the Top and Bottom shoreline of River
    int getRiverNorth(){
        return top;
    }
    int getRiverSouth(){
        return top + bottom;
    }

    void draw(Graphics g) {
        g.setColor(ColorUtil.BLUE);
        g.drawRect(start, top, end, bottom);
    }
}

class Helipad {
    private final static int DISP_W = Display.getInstance().getDisplayWidth();
    private final static int DISP_H = Display.getInstance().getDisplayHeight();
    private Point locationCenter;
    private int squareSize, circleSize;

    public Helipad(){
        squareSize = 200;
        circleSize = 150;
        locationCenter = new Point(DISP_W/2, DISP_H - squareSize -
                squareSize/2 );
    }
    // Get Helipads X and Y coordinates
    public int getHelipadX() {
        return locationCenter.getX() - squareSize/2;
    }
    public int getHelipadY() {
        return locationCenter.getY() - squareSize/2;
    }
    public int getHelipadSize() {
        return squareSize;
    }

    void draw(Graphics g){
        g.setColor(ColorUtil.GRAY);
        g.drawArc(locationCenter.getX() - circleSize/2,
                locationCenter.getY() - circleSize/2,
                circleSize, circleSize, 0, 360);
        g.drawRect(locationCenter.getX() - squareSize/2,
                locationCenter.getY() - squareSize/2,
                squareSize, squareSize,5);
    }
}

class Fire {
    private final static int DISP_W = Display.getInstance().getDisplayWidth();
    private final static int DISP_H = Display.getInstance().getDisplayHeight();
    private Point location;
    private int fireSize;
    private Random r;

    public Fire(){
        r = new Random();
        fireSize = r.nextInt(200);
        location = new Point(DISP_W/4 + r.nextInt(DISP_W/4),
                r.nextInt(DISP_H)/4);
    }
    // Increase and decrease fire's size
    void grow(){
        fireSize = fireSize + r.nextInt(5);
    }

    public int shrink(int water) {
        fireSize = fireSize - (water/2);
        return fireSize;
    }
    // Gets the Point coordinate for Fires X and Y and the fire's size
    int getFireX() {
        return location.getX() - fireSize/4;
    }
    int getFireY(){
        return location.getY() - fireSize/4;
    }
    int getFireSize(){
        return fireSize;
    }
    void setLocationX(int locX) {
        location.setX(locX);
    }
    void setLocationY(int locY){
        location.setY(locY);
    }

    void draw(Graphics g) {
        g.setColor(ColorUtil.rgb(255, 0, 0));
        g.fillArc(location.getX() - fireSize/4,
                location.getY() - fireSize/4,
                fireSize/2, fireSize/2,
                0, 360);
        g.setColor(ColorUtil.WHITE);
        g.setFont(Font.createSystemFont(FACE_MONOSPACE, STYLE_BOLD,
                SIZE_MEDIUM));
        g.drawString("" + fireSize, location.getX() + (fireSize/4),
                location.getY() + (fireSize/4));
    }
}

class Helicopter {
    private final static int DISP_W = Display.getInstance().getDisplayWidth();
    private final static int DISP_H = Display.getInstance().getDisplayHeight();
    private Point locationHeli, locationTail, center, turning, forwardPoints;
    private int heliSize, tailSize, currentIndex, rXs, rYs;
    private int  fuel, rX, rY, speed, x2, y2, water;
    private ArrayList<Point> turn, forward;

    public Helicopter(){
        heliSize = 50;
        tailSize = 100;
        locationHeli = new Point(DISP_W/2,
                DISP_H - 300);
        locationTail = new Point(locationHeli.getX(), locationHeli.getY());
        center = new Point(DISP_W/2, DISP_H - 300);
        turn = new ArrayList<>();
        currentIndex = 0;
        fuel = 25000;
        for (int i = 1; i < 25; i++) {
            double angle = Math.toRadians(360 / 24 * i - 105);
            rX = (int) ((tailSize * Math.cos(angle)));
            rY = (int) ((tailSize * Math.sin(angle)));
            turning = new Point(rX, rY);
            turn.add(turning);
        }
    }
    // Changes the direction the helicopter is pointing
    void move(){
        forward = new ArrayList<>();
        for (int i = 1; i < 25; i++) {
            double angle = Math.toRadians(360 / 24 * i - 105);
            rXs = (int)(Math.cos(angle) * speed);
            rYs =  (int)(Math.sin(angle) * speed);
            forwardPoints = new Point(rXs, rYs);
            forward.add(forwardPoints);
        }
            center.setX(center.getX() + (forward.get(currentIndex).getX()));
            center.setY(center.getY() + (forward.get(currentIndex).getY()));

    }
    // Uses the turn ArrayList to change direction
    void turningR() {
        currentIndex++;
        if (currentIndex > turn.size() - 1) {
            currentIndex = 0;
        }
    }
    // Uses the turn ArrayList to change direction
    void turningL(){
        if(currentIndex == 0){
            currentIndex = turn.size() - 1;
        }
        currentIndex--;
    }
    // changes the speed of the helicopter
    void accelerate(){
        if(speed >= 0 && speed < 10) {
            speed++;
        }
        else{
            speed = 10;
        }
    }
    // changes the speed of the helicopter
    void decelerate() {
        if(speed > 0) {
            speed--;
        }
        else{
            speed = 0;
        }
    }
    // Changes the fuel level
    int fuelConsumption(){
            fuel = fuel - ((speed * speed) + 5);

            if(fuel <= 0) {
                fuel = 0;
            }
            return fuel;
    }
    // Command method to pick up Water
    void drinkWater(){
        if(speed < 3){
            water = water + 100;
            }
        if(water >= 1000){
            water = 1000;
        }
    }
    // Checks to see if center of helicopter is over the river
    boolean overRiver(River r){
        if((r.getRiverNorth() + heliSize/2 < center.getY()) &&
                (r.getRiverSouth() - heliSize/2 > center.getY())){
            return true;
        }
        else{
            return false;
        }
    }
    // Check is helicopter is over the fire
    boolean overFire(Fire f) {
        if ((f.getFireX() < center.getX()) &&
                ((f.getFireX() + f.getFireSize()) > center.getX()) &&
                (f.getFireY() < center.getY()) &&
                (((f.getFireY() + f.getFireSize()) > center.getY())))
         {
            return true;
        } else {
            return false;
        }
    }
    // Check to see if Helicopter is over the Helipad
    boolean isOverHelipad(Helipad pad) {
        return (pad.getHelipadX() < center.getX()) &&
                ((pad.getHelipadX() + pad.getHelipadSize()) > center.getX()) &&
                (pad.getHelipadY() < center.getY()) &&
                ((pad.getHelipadY() + pad.getHelipadSize()) > center.getY()) &&
                (speed == 0);
    }
    // Current Water Level
    int getWaterLevel(){ return water; }
    // Drops all water of fire
    void fightFire(){ water = 0; }

    void draw(Graphics g) {
        g.setColor(ColorUtil.rgb(255, 255, 0));
        g.fillArc(center.getX() - heliSize / 2,
                center.getY() - heliSize / 2,
                heliSize, heliSize, 0, 360);
        x2 = turn.get(currentIndex).getX() + center.getX();
        y2 = turn.get(currentIndex).getY() + center.getY();
        g.drawLine(center.getX(), center.getY(), x2, y2);
        g.setColor(ColorUtil.WHITE);
        g.setFont(Font.createSystemFont(FACE_MONOSPACE, STYLE_BOLD,
                SIZE_MEDIUM));
        g.drawString("f: " + fuel, center.getX() + heliSize,
                center.getY() + heliSize);
        g.drawString("w: " + water, center.getX() + heliSize,
                center.getY() + 20 + heliSize);
    }
}
